.var dummy

#====================================
# Click functions
#====================================

%deffunc getClick (p_idElt p_evtSug)
#        --------
	{ext ($p_idElt) `
		const lElt = document.querySelector(args[0])
		lElt.disabled = false
		if (lElt===null) console.log("ERROR !!! libDOM.fs/getClick '" + args[0] + "' selector references no element!")
		const l_react = function(evt) {
			lElt.removeEventListener('click', l_react)
			lElt.disabled = false
			output()
		};
		lElt.addEventListener('click', l_react)
	` $p_evtSug}

%deffunc awaitClickBip (p_idElt)
#        -------------
	{seq
		.var evtSug
		(&getClick $p_idElt evtSug)
		:await evtSug bip
	}

%deffunc awaitClickBeep (p_idElt)
#        --------------
	{seq
		.var evtSug
		(&getClick $p_idElt evtSug)
		:await evtSug beep
	}

#====================================
# Display functions
#====================================

%deffunc displayNewMessageIn (p_message p_idAnchor)
#        -------------------
	{ext ($p_message $p_idAnchor) `
		const lList_idAnchor = args[1].split('/')
		const ls_idAnchor = lList_idAnchor[0]
		const ls_class = (lList_idAnchor.length>1) ? lList_idAnchor[1] : 'other'
		const lElt_anchor = document.querySelector(ls_idAnchor)
		if (lElt_anchor===null) console.log("ERROR !!! libDOM.fs/displayNewMessageIn '" + ls_idAnchor + "' selector references no element!")
		const lElt = document.createElement('p')
		lElt.classList.add('display')
		lElt.classList.add(ls_class)
		lElt.innerHTML = args[0]
		lElt_anchor.appendChild(lElt)
		lElt.scrollIntoView()
	` dummy}

%deffunc displayNewMessage (p_message)
#        -----------------
	(&displayNewMessageIn $p_message 'body')

%deffunc displayMessageIn (p_message p_idAnchor)
#        ----------------
	{ext ($p_message $p_idAnchor) `
		const lElt_anchor = document.querySelector(args[1])
		if (lElt_anchor===null) console.log("ERROR !!! libDOM.fs/displayMessageIn '" + args[1] + "' selector references no element!")
		lElt_anchor.innerHTML = args[0]
		lElt_anchor.scrollIntoView()
	` dummy}

#====================================
# Input functions
#====================================

%deffunc inputNewHumanTextIn (p_evtSugB p_idAnchor)
#        -------------------
	{ext ($p_idAnchor) `
		const lElt_anchor = document.querySelector(args[0])
		if (lElt_anchor===null) console.log("ERROR !!! libDOM.fs/inputNewHumanTextIn '" + args[0] + "' selector references no element!")
		const lElt = document.createElement('p')
		const lSAVE = {}
		lSAVE.elt = lElt
		lElt.classList.add('entry')
		lElt.classList.add('self')
		lElt.setAttribute('contentEditable', 'true')
		setTimeout(O=>lElt.focus(), 0)
		const l_react = function(evt) {
			if (evt.inputType==="insertParagraph") {
				lElt.removeEventListener('beforeinput', l_react)
				lElt.setAttribute('contentEditable', 'false')
				lElt.classList.replace('entry', 'display')
				evt.preventDefault()
				//console.log('OK', evt.target.textContent)
				output(evt.target.textContent)
			}
		}
		lSAVE.react = l_react
		SAVES.push(lSAVE)
		lElt.addEventListener('beforeinput', l_react)
		lElt_anchor.appendChild(lElt)
	` $p_evtSugB `
		SAVE.elt.removeEventListener('beforeinput', SAVE.react)
		SAVE.elt.setAttribute('contentEditable', 'false')
		SAVE.elt.classList.replace('entry', 'display')
		SAVE.elt.classList.add('canceled')
	`}

%deffunc inputNewHumanText (p_evtSugB)
#        -----------------
	(&inputNewHumanTextIn $p_evtSugB 'body')

%deffunc awaitNewHumanTextIn (p_idAnchor)
#        -------------------
	{seq
		.var evtSugA
		(&inputNewHumanTextIn evtSugA $p_idAnchor)
		:await evtSugA beep
	}

%deffunc awaitNewHumanNumberIn (p_idAnchor)
#        ---------------------
	{seq
		.var tryText <-- 'notANumber'
		.var whileA
		{while @whileA true {seq
			:set tryText (&awaitNewHumanTextIn $p_idAnchor)
			{if :and .not [$tryText < 0] .not [$tryText >= 0]
				(&displayNewMessageIn 'This is not a number!' :+ $p_idAnchor '/error')
			else
				.break whileA
			}
		}}
		$tryText
	}

%deffunc awaitHumanText ()
#        --------------
	{seq
		.var evtSugA
		(&inputNewHumanText evtSugA)
		:await evtSugA beep
	}

#====================================
# Time functions
#====================================

%deffunc waitMilliseconds (p_nMilliseconds)
#        -----------
	{seq
		.var waitEnd
		{ext ($p_nMilliseconds) `
			setTimeout(
				O=>output(args[0]),
				args[0]
			)
		` waitEnd}
		:await waitEnd beep
	}

%deffunc waitSeconds (p_nSeconds)
#        -----------
	(&waitMilliseconds :* 1000 $p_nSeconds)
