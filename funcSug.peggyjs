{
	function Expression(type, content, text, exprLabel, cancelExpression, multLabel) {
		this.type = type
		this.content = content
		this.text = text
		this.exprLabel = exprLabel
		this.cancelExpression = cancelExpression
		this.multLabel = multLabel
		this.location = location()
	}
	input = input.replaceAll(/&([A-Za-z_]+)/g, 'call $$$1')
	input = input.replaceAll(/([A-Za-z_]+)[.]([0-9A-Za-z_]+)[.]([0-9A-Za-z_]+) <-- /g, '%setToNamespace :getFromNamespace $$$1 $2 $3 ')
	input = input.replaceAll(/([A-Za-z_]+)[.]([0-9A-Za-z_]+) <-- /g, '%setToNamespace $$$1 $2 ')
	input = input.replaceAll(/[$]([A-Za-z_]+)[.]([0-9A-Za-z_]+)[.]([0-9A-Za-z_]+)/g, ':getFromNamespace :getFromNamespace $$$1 $2 $3')
	input = input.replaceAll(/[$]([A-Za-z_]+)[.]([0-9A-Za-z_]+)/g, ':getFromNamespace $$$1 $2')
	input = input.replaceAll(/[{]deffunc ([A-Za-z_]+) /g, '.var $1 :set $1 {lambda ') // '}}'
	input = input.replaceAll(/.var\s+([A-Za-z_]+) <-- /g, '.var $1 :set $1 ')
	input = input.replaceAll('$_', '.evalget _')
	input = input.replaceAll(/\n(\s*)(#?)(.*)<--(.*)(?=\n)/g, '\n$1$2[ $3 <- $4 ]')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\+\s*/g, '$1 <- [ $$$1 + ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\*\s*/g, '$1 <- [ $$$1 * ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\-\s*/g, '$1 <- [ $$$1 - ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\/\s*/g, '$1 <- [ $$$1 / ')
	input = input.replaceAll('<-', ' set ')
}

start
	= program

program
	= __ expr:expression __ { return new Expression('program', expr, expr.text) }

expression
	= "(" __ startExpr:expression expr:WSexpression* __ ")" { return new Expression('expression', [startExpr].concat(expr), text() ) }
	/ "[" __ startExpr:expression expr:WSexpression* __ "]" { return new Expression('expression', [startExpr].concat(expr), text() ) }
	/ "{" __ startExpr:expression exprLabel:exprLabel? multLabel:multLabel? expr:WSexpression* __ "}" cancelExpression:cancelExpression? { return new Expression('expression', [startExpr].concat(expr), text(), exprLabel, cancelExpression, multLabel ) }
	/ number / string / name
	/ expression0 / expression1 / expression2 / expression3 / expression4 / expressionEmpty

cancelExpression
	= __ "~" __ expr:expression { return expr; }

WSexpression
	= spaces expr:expression { return expr; }

expression0
	= "!" n:name { return new Expression('expression', [n], text()) }

expression1
	= "." n:name spaces e1:expression { return new Expression('expression', [n, e1], text()) }

expression2
	= ":" n:name spaces e1:expression spaces e2:expression { return new Expression('expression', [n, e1, e2], text()) }

expression3
	= "%" n:name spaces e1:expression spaces e2:expression spaces e3:expression { return new Expression('expression', [n, e1, e2, e3], text()) }

expression4
	= "$" expr:expression { return new Expression('expression', [new Expression('identifier', 'get', 'get'), expr], text()) }

expressionEmpty
	= "(" spac:__ ")" { return new Expression('expression', [], text()) }

exprLabel
	= spaces "@" n:[A-Za-z_]+ { return n.join("") }

multLabel
	= spaces "*" n:[A-Za-z_]+ { return n.join("") }

name
	= simpleName

simpleName
	= n:[A-Za-z_=+*/<>-]+ { return new Expression('identifier', n.join(""), n.join("")) }

__
	= (comment / singleSpace / newline)*

spaces
	= (comment / singleSpace / newline)+

comment
	= "#" [^\n\r]* newline

singleSpace
	= [ \t]

whiteSpace
	= [ \t\n\r]+

newline
	= [\n\r]

number
	= digits:("-"?[0-9]+) { return new Expression('number', parseInt((digits[0] || '') + digits[1].join(""), 10), (digits[0] || '') + digits[1].join("")) }

string
	= '"' content:[^"]* '"' { return new Expression('string', content.join(""), '"'+content.join("")+'"' ) }
	/ "'" content:[^']* "'" { return new Expression('string', content.join(""), "'"+content.join("")+"'" ) }
	/ '`' content:[^`]* '`' { return new Expression('string', content.join(""), '`'+content.join("")+'`' ) }
