{
	let indentationCount = 0
	function Expression(type, content, text, exprLabel, cancelExpression, multLabel) {
		this.type = type
		this.content = content
		this.text = text
		this.exprLabel = exprLabel
		this.cancelExpression = cancelExpression
		this.multLabel = multLabel
		this.location = location()
	}
	input = input.replaceAll(/&([A-Za-z_]+)/g, 'call $$$1')
	input = input.replaceAll(/([A-Za-z_]+)[.]([0-9A-Za-z_]+)[.]([0-9A-Za-z_]+) <-- /g, '%setToNamespace :getFromNamespace $$$1 $2 $3 ')
	input = input.replaceAll(/([A-Za-z_]+)[.]([0-9A-Za-z_]+) <-- /g, '%setToNamespace $$$1 $2 ')
	input = input.replaceAll(/:await\s+([A-Za-z_]+)[.]([0-9A-Za-z_]+)/g, '%awaitInNamespace $$$1 $2 ')
	input = input.replaceAll(/[$]([A-Za-z_]+)[.]([0-9A-Za-z_]+)[.]([0-9A-Za-z_]+)/g, ':getFromNamespace :getFromNamespace $$$1 $2 $3')
	input = input.replaceAll(/[$]([A-Za-z_]+)[.]([0-9A-Za-z_]+)/g, ':getFromNamespace $$$1 $2')
	input = input.replaceAll(/[{]deffunc ([A-Za-z_]+) /g, '.var $1 :set $1 {lambda ') // '}}'
	input = input.replaceAll(/.var\s+([A-Za-z_]+) <-- /g, '.var $1 :set $1 ')
	input = input.replaceAll('$_', '.evalget _')
	input = input.replaceAll(/\n(\s*)(#?)(.*)<--(.*)(?=\n)/g, '\n$1$2[ $3 <- $4 ]')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\+\s*/g, '$1 <- [ $$$1 + ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\*\s*/g, '$1 <- [ $$$1 * ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\-\s*/g, '$1 <- [ $$$1 - ')
	input = input.replaceAll(/([A-Za-z_]+)\s*<-\s*\[\s*\/\s*/g, '$1 <- [ $$$1 / ')
	input = input.replaceAll('<-', ' set ')
}

start
	= program

program
	= __ expr:expression __ { return new Expression('program', expr, expr.text) }

expression
	= "(" __ startExpr:expression expr:WSexpression* __ ")" { return new Expression('expression', [startExpr].concat(expr), text() ) }
	/ "[" __ startExpr:expression expr:WSexpression* __ "]" { return new Expression('expression', [startExpr].concat(expr), text() ) }
	/ "{" __ startExpr:expression exprLabel:exprLabel? multLabel:multLabel? expr:WSexpression* __ "}" cancelExpression:cancelExpression? { return new Expression('expression', [startExpr].concat(expr), text(), exprLabel, cancelExpression, multLabel ) }
	/ number / string / name
	/ expression0 / expression1 / expression2 / expression3 / expression4 / expressionBlock1 / expressionEmpty

cancelExpression
	= __ "~" __ expr:expression { return expr; }

WSexpression
	= spaces expr:expression { return expr; }

expression0
	= "!" n:name { return new Expression('expression', [n], text()) }

expression1
	= "." n:name spaces e1:expression { return new Expression('expression', [n, e1], text()) }

expression2
	= ":" n:name spaces e1:expression spaces e2:expression { return new Expression('expression', [n, e1, e2], text()) }

expression3
	= "%" n:name spaces e1:expression spaces e2:expression spaces e3:expression { return new Expression('expression', [n, e1, e2, e3], text()) }

expression4
	= "$" expr:expression { return new Expression('expression', [new Expression('identifier', 'get', 'get'), expr], text()) }

expressionBlock1
	= "|" e1:expression exprLabel:exprLabel? " "* newline INDENT multLabel:multLabel? startExpr:expression restExpr:(newline SAMEDENT expression " "*)* DEDENT { return new Expression('expression', [e1,startExpr].concat(restExpr), text(), exprLabel, null, multLabel ) }

expressionEmpty
	= "(" spac:__ ")" { return new Expression('expression', [], text()) }

exprLabel
	= spaces "@" n:[A-Za-z_]+ { return n.join("") }

multLabel
	= spaces "*" n:[A-Za-z_]+ { return n.join("") }

name
	= simpleName

simpleName
	= n:[A-Za-z_=+*/<>-]+ { return new Expression('identifier', n.join(""), n.join("")) }

__ "optSpaces"
	= (comment / singleSpace / newline)*

spaces "spaces"
	= (comment / singleSpace / newline)+

comment "comment"
	= "#" [^\n\r]* newline

singleSpace "singleSpace"
	= [ \t]

whiteSpace "whiteSpace"
	= [ \t\n\r]+

newline "newline"
	= [\n\r]

number "number"
	= digits:("-"?[0-9]+([.][0-9]+)?) {
		return new Expression(
			'number',
			parseFloat(  text()   ),
			text()
		)
	}

string "string"
	= '"' content:[^"]* '"' { return new Expression('string', content.join(""), text() ) }
	/ "'" content:[^']* "'" { return new Expression('string', content.join(""), text() ) }
	/ '`' content:[^`]* '`' { return new Expression('string', content.join(""), text() ) }

// inspired by https://github.com/Kantouzin/python-pegjs
SAMEDENT
	= tabs:tabs &{return tabs.length == indentationCount} {}

INDENT
	= tabs:tabs &{return tabs.length == indentationCount + 1} {indentationCount += 1}

DEDENT
	= tabs:tabs &{return tabs.length == indentationCount - 1} {indentationCount -= 1}

tabs "tabs"
	= '\t'*
